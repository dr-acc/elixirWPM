defmodule ElixirWPM.Snippets do
  @snippets [
    "Enum.map([1, 2, 3], fn x -> x * 2 end)",
    "if(foo, do: bar)",
    "IO.inspect(number)",
    "[1, 2, 3] = [a, b, c]",
    "{elixir: \"rules\"}",
    "add = fn a, b -> a + b end",
    "for n <- [1, 2, 3, 4], do: n * 2",
    "Float.floor(12.52, 2)",
    "Float.ceil(34.25)",
    "Float.to_charlist(7.0)",
    "start = DateTime.utc_now()",
    "text_input = form_data[\"textinput\"][\"name\"]",
    "IO.puts \"Hello, world!\"",
    "defmodule MyApp do end",
    "def my_function(x) do x + 1 end",
    "for i in 1..10, do: i * i",
    "if x > 10, do: x is greater than 10, else: x is less than or equal to 10 end",
    "Enum.map(list, fn x -> x * 2 end)",
    "Enum.filter(list, fn x -> x > 10 end)",
    "Enum.take(list, 5)",
    "Enum.drop(list, 5)",
    "Enum.reverse(list)",
    "Enum.uniq(list)",
    "Enum.sort(list)",
    "Enum.min(list)",
    "Enum.max(list)",
    "IO.read(:line)",
    "IO.write(\"Hello, \", name, \"!\")",
    "File.read(\"filename.txt\")",
    "File.write(\"filename.txt\", \"This is the new content of the file.\")",
    "spawn(fn -> sleep 500; IO.puts \"This is a message from a spawned process.\" end)",
    "defmodule MyApp do end",
"def my_function(x) do x + 1 end",
"for i in 1..10, do: i * i",
"if x > 10, do: \"x is greater than 10\", else: \"x is less than or equal to 10\" end",
"IO.puts \"Hello, world!\"",
"IO.read(:line)",
"IO.write(\"Hello, \", name, \"!\")",
"File.read(\"filename.txt\")",
"File.write(\"filename.txt\", \"This is the new content of the file.\")",
"spawn(fn -> sleep 500; IO.puts \"This is a message from a spawned process.\" end)",
"{x, y} = {1, 2}",
"x = 1, y = 2",
"if x == y, do: \"x and y are equal\", else: \"x and y are not equal\" end",
"for x in 1..10, do: IO.puts x",
"Enum.each(1..10, fn x -> IO.puts x end)",
"Enum.reduce(1..10, fn x, acc -> x + acc end)",
"Enum.map(1..10, fn x -> x * 2 end)",


  ]
  def random() do
    Enum.random(@snippets)
  end
end

# "|> Enum.group_by(&(&1.name), &(&1.ids))",
#     "|> Enum.map(fn {color, ids} -> %{name: color, ids: List.flatten(ids)} end)",
#     "|> Enum.reduce(%{}, fn %{ids: ids, name: name}, acc ->",
#     "Map.update(acc, name, ids, fn prev_ids -> prev_ids ++ ids end)",
#     "|> Enum.map(fn {color, ids} -> %{name: color, ids: ids} end)",
#     "conn |> Plug.Conn.assign(:name, Keyword.get(opts, :name, background_job))",
#     "Enum.map(map, fn {k, v} -> {k, v * 2} end)",
